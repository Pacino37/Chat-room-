// server.js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// Serve static client files from public/
app.use(express.static('public'));

// In-memory store (for demo; use a DB for production)
const rooms = {}; // roomId -> { users: Map(socketId -> {id, username, muted, isAdmin}) , adminPassword }
const DEFAULT_ADMIN_PASSWORD = 'admin123';

function ensureRoom(roomId) {
  if (!rooms[roomId]) {
    rooms[roomId] = {
      users: new Map(),
      adminPassword: DEFAULT_ADMIN_PASSWORD
    };
  }
  return rooms[roomId];
}

io.on('connection', (socket) => {
  console.log('Socket connected:', socket.id);

  socket.on('join-room', ({ roomId = 'main-room', username = 'guest', muted = false }) => {
    roomId = String(roomId);
    username = String(username);
    const room = ensureRoom(roomId);

    socket.join(roomId);
    room.users.set(socket.id, { id: socket.id, username, muted: !!muted, isAdmin: false });

    // Reply to the joining client
    socket.emit('joined-success', { id: socket.id, room: roomId, username });

    // Inform this client about other users (ids) - useful for some client flows
    const otherIds = Array.from(room.users.keys()).filter(id => id !== socket.id);
    socket.emit('all-users', otherIds);

    // Broadcast updated user list to room
    const usersList = Array.from(room.users.values()).map(u => ({ id: u.id, username: u.username }));
    io.in(roomId).emit('user-list', usersList);

    // Notify others someone joined
    socket.to(roomId).emit('user-joined', { id: socket.id, username });

    console.log(`${username} joined ${roomId} (${socket.id})`);
  });

  socket.on('admin-login', ({ roomId = 'main-room', password = '' }) => {
    roomId = String(roomId);
    const room = ensureRoom(roomId);
    const success = password === room.adminPassword;
    if (success) {
      // mark the socket user as admin in room storage (if joined already)
      const user = room.users.get(socket.id) || {};
      user.isAdmin = true;
      room.users.set(socket.id, user);
      socket.join(`${roomId}-admins`); // optional separate admin room
      socket.emit('admin-login-result', { success: true, message: 'Welcome, admin' });

      // send updated list (to show admin controls)
      const usersList = Array.from(room.users.values()).map(u => ({ id: u.id, username: u.username }));
      io.in(roomId).emit('user-list', usersList);
      console.log(`Admin login success for ${socket.id} in ${roomId}`);
    } else {
      socket.emit('admin-login-result', { success: false, message: 'Invalid password' });
      console.log(`Admin login failed for ${socket.id} in ${roomId}`);
    }
  });

  // Called by client when they have local media and are ready
  socket.on('ready-for-call', ({ roomId = 'main-room', username = '' }) => {
    // server currently does not need to do extra work here; leave for extensibility
    // Could notify others this client is ready
    socket.to(roomId).emit('system message', `${username || socket.id} is ready for call`);
  });

  // Chat
  socket.on('chat message', ({ text, roomId, user }) => {
    io.in(roomId).emit('chat message', { user: user || 'guest', text });
  });

  // Raise hand
  socket.on('raise-hand', ({ username, roomId, id }) => {
    io.in(roomId).emit('raise-hand', { username, id });
  });

  // Signaling relay: offer, answer, ice-candidate
  socket.on('offer', ({ to, sdp }) => {
    if (!to) return;
    io.to(to).emit('offer', { from: socket.id, sdp });
  });

  socket.on('answer', ({ to, sdp }) => {
    if (!to) return;
    io.to(to).emit('answer', { from: socket.id, sdp });
  });

  socket.on('ice-candidate', ({ to, candidate }) => {
    if (!to) return;
    io.to(to).emit('ice-candidate', { from: socket.id, candidate });
  });

  // Admin actions - server routes actions to appropriate sockets
  socket.on('admin-action', (action) => {
    try {
      const { type, target, roomId } = action || {};
      if (!roomId) return;
      const room = ensureRoom(roomId);

      // Verify sender is admin in this room
      const sender = room.users.get(socket.id);
      if (!sender || !sender.isAdmin) {
        socket.emit('system message', 'Admin action denied: not an admin');
        return;
      }

      // Server-side handling and broadcasting:
      if (type === 'mute-all') {
        // broadcast to room instructing clients to mute
        io.in(roomId).emit('admin-action', { type: 'mute-all' });
      } else if (type === 'disable-video') {
        io.in(roomId).emit('admin-action', { type: 'disable-video' });
      } else if (type === 'enable-audio') {
        io.in(roomId).emit('admin-action', { type: 'enable-audio' });
      } else if (type === 'mute-user' && target) {
        io.to(target).emit('admin-action', { type: 'mute-user', target });
      } else if (type === 'unmute-user' && target) {
        io.to(target).emit('admin-action', { type: 'unmute-user', target });
      } else if (type === 'disable-video-user' && target) {
        io.to(target).emit('admin-action', { type: 'disable-video-user', target });
      } else {
        // unrecognized - broadcast as-is to room for custom clients
        io.in(roomId).emit('admin-action', action);
      }

      // optionally update server-side user state for target (muted flags)
      if (type === 'mute-user' && target) {
        const t = room.users.get(target);
        if (t) t.muted = true;
      } else if (type === 'unmute-user' && target) {
        const t = room.users.get(target);
        if (t) t.muted = false;
      } else if (type === 'mute-all') {
        room.users.forEach(u => u.muted = true);
      }

    } catch (err) {
      console.error('admin-action error:', err);
    }
  });

  // When someone leaves / disconnects
  socket.on('disconnect', () => {
    console.log('Socket disconnect:', socket.id);
    // remove from any room
    Object.keys(rooms).forEach(roomId => {
      const room = rooms[roomId];
      if (room.users.has(socket.id)) {
        const username = room.users.get(socket.id).username;
        room.users.delete(socket.id);
        // notify remaining clients
        socket.to(roomId).emit('user-left', socket.id);
        const usersList = Array.from(room.users.values()).map(u => ({ id: u.id, username: u.username }));
        io.in(roomId).emit('user-list', usersList);
        console.log(`${username || socket.id} removed from ${roomId}`);
      }
    });
  });

  // Optional: allow a client to explicitly leave a room
  socket.on('leave-room', ({ roomId }) => {
    const room = rooms[roomId];
    if (!room) return;
    if (room.users.has(socket.id)) {
      room.users.delete(socket.id);
      socket.leave(roomId);
      socket.to(roomId).emit('user-left', socket.id);
      const usersList = Array.from(room.users.values()).map(u => ({ id: u.id, username: u.username }));
      io.in(roomId).emit('user-list', usersList);
    }
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
});
